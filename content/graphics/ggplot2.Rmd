---
title: "Graphics with ggplot2"
---

This .Rmd file can be composed into a Notebook result (.html or .pdf) with RStudio. Any of the R code chunks can also be submitted or be part of a batch Rscript submission.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First, we load the library.
```{r}
library(ggplot2)
```

Next, consider the `mpg` dataset that is included with the ggplot2 library.
``` {r}
tail(mpg)
```

ggplot is based on the Grammar of Graphics decomposition of graphing concepts, which allows very high-level control over graphics along with the ability to tune fine details. It is considered the gold standard for publication quality graphics. It is currently used by publications like The New York Times and The Economist due to its ability to quickly prototype custom graphics.

Grphics are decomposed into layers. Let's begin with an empty xy-plot. The aesthetics `aes()` function assigns `x = cty` and `y = hwy`.
``` {r}
g = ggplot(mpg, aes(cty, hwy))
g
```

Now we add `geom_point()` to tell ggplot how to represent the xy data. The `print()` can be ommitted as the `print()` method is the default for an object that is not assigned.
``` {r}
g = ggplot(mpg, aes(cty, hwy)) +
    geom_point()
g
```

Add another layer with a LOESS (locally estimated scatterplot smoothing) regression line and a confidence region (95% by default) for the line.
``` {r}
g = ggplot(mpg, aes(cty, hwy)) +
    geom_point() +
    geom_smooth()
g
```

Customize axes, theme, etc. Notably, we choose generalized additive models from the package `mgcv` to fit thin plate splines with crossvalidation to the data instead of the default LOESS above. Again, a 95% confidence region is shown for the local mean.
``` {r}
g = ggplot(mpg, aes(cty, hwy)) +
    geom_point(shape = 17, size = 2) +
    geom_smooth(method = mgcv::gam, formula = y ~ s(x, bs = "tp")) +
    labs(x = "City", y = "Highway", title = "Miles Per Gallon") +
    theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
g
```

Now change the aesthetics to `x = hwy`, dropping the `y`, and its representation to a histogram.
``` {r}
g = ggplot(mpg, aes(hwy)) +
    geom_histogram()
g
```

Customize the histogram.
``` {r}
g = ggplot(mpg, aes(hwy)) +
    geom_histogram(bins=20, fill="blue", color="black", size=0.25)
g
```

Plot a histogram for each value of `cyl`.
``` {r}
g = ggplot(mpg, aes(hwy)) +
    geom_histogram(bins=20, fill="blue", color="black", size=0.25) +
    facet_wrap(~ cyl)
g
```

Plot boxplots for each value of `class`.
``` {r}
g = ggplot(mpg, aes(class, hwy)) +
    geom_boxplot()
g
```

Plot two boxplots together horizontally.
``` {r}
library(gridExtra)

g = ggplot(mpg, aes(class, hwy)) +
    geom_boxplot()
h = ggplot(mpg, aes(class, cty)) +
    geom_boxplot()
grid.arrange(g, h)
```

Suppose we have an autoregressive Gaussian process  of order 2, denoted by AR(2), time series model
\begin{align*}
y_t = \phi_1 y_{t-1} + \phi_2 y_{t-2} + \epsilon_t, \quad
\epsilon_t \stackrel{\text{iid}}{\sim} \text{N}(0, \sigma^2),
\quad t = 1, \ldots, n.
\end{align*}

Generate an AR(2) series and plot it.
``` {r}
y = arima.sim(n = 200, list(ar = c(0.5, -0.2), sd = sqrt(0.25)))
dat = data.frame(t = 1:200, y = as.numeric(y))
g = ggplot(dat, aes(t, y)) + geom_line()
g
```

What about plotting multiple series on one plot? First draw the series.
``` {r}
n = 200
y1 = 0 + arima.sim(n = n, list(ar = c(0.5, -0.2), sd = sqrt(0.25)))
y2 = 3 + arima.sim(n = n, list(ar = c(0.1, -0.2), sd = sqrt(0.25)))
y3 = -3 + arima.sim(n = n, list(ar = c(0.7, -0.2), sd = sqrt(0.5)))
```

Make the series columns of a `data.frame`.
``` {r}
dat = data.frame(t = 1:n, y1 = as.numeric(y1), y2 = as.numeric(y2), y3 = as.numeric(y3))
head(dat, 3)
```

Reshape the `data.frame` by stacking the series vertically.
``` {r}
library(reshape2)
newdat = melt(dat, 't')
head(newdat)
tail(newdat)
```

Here is one way to plot the series together.
``` {r}
g = ggplot(newdat, aes(x = t, y = value,
            group = variable,
            color = variable,
            linetype = variable)) +
    geom_line() +
    theme(legend.position = "bottom") +
    ggtitle("Multiple Series")
g
```

Draw from bivariate normal.
``` {r}
library(mvtnorm)
Sigma = matrix(c(1, 1/2, 1/2, 1), 2, 2)
x = rmvnorm(n = 10000, mean = c(0,0), sigma = Sigma)
dat = data.frame(x)
colnames(dat) = c("x", "y")
```

Plot the points and superimpose contours.
``` {r}
g = ggplot(dat, aes(x=x, y=y)) +
    geom_point(alpha = 0.2) +
    geom_density2d()
g
```

Plot bins instead to display density values.
``` {r}
g = ggplot(dat, aes(x=x, y=y)) +
    geom_bin2d() +
    scale_fill_gradient(low = "blue", high = "red")
g
```

Plot hexigonal bins instead.
``` {r}
library(hexbin)
g = ggplot(dat, aes(x=x, y=y)) +
    geom_hex() +
    scale_fill_gradient(low = "blue", high = "red") +
    coord_cartesian(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5)) +
    theme(legend.position = "bottom")
g
```

Generate data from a trinomial distribution.
``` {r}
m = 10
grid = expand.grid(x = 0:m, y = 0:m)
grid = grid[grid$x + grid$y <= m,]
grid$z = m - grid$x - grid$y
```

Plot the trinomial data on a 2-d grid (no need to display the redundant third coordinate).
``` {r}
grid$dens = apply(grid, 1, dmultinom, size=m, prob=c(0.1, 0.3, 0.6))
g = ggplot(grid, aes(x=x, y=y)) +
    geom_raster(aes(fill = dens)) +
    scale_fill_gradient(low = "yellow", high = "red") +
    scale_x_discrete(limits = 0:m) +
    scale_y_discrete(limits = 0:m)
g
```

To save the last plot, use `ggsave`. File type is determined by extension (pdf, png, jpg, etc).
``` {r, eval = FALSE}
ggsave("plot.pdf", width = 5, height = 5)
```
